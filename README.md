# Лабораторная работа 7: Преобразование и анализ кода с использованием Clang и LLVM

## Цель работы
Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.

## Ход работы

### 1. Установка и подготовка среды
Установлены следующие инструменты в среде Ubuntu 22.04:
- `clang` — компилятор языка C/C++;
- `llvm` — инструменты анализа и оптимизации кода;
- `opt` — инструмент для работы с LLVM IR и применения оптимизаций;
- `Graphviz` — инструмент для визуализации кода.
**Команда для установки:**
```bash
sudo apt install clang llvm graphviz
```
![Установка_CLANG](![image](https://github.com/user-attachments/assets/d755fca3-1278-4227-866a-201c946514c8))
![Установка_Graphviz](![image](https://github.com/user-attachments/assets/42a426b4-6a35-49d4-a124-d8580f843296))
### 2. Создание файла C
![Код](![image](https://github.com/user-attachments/assets/7b0276d2-191a-44ba-afd1-513fb52a43cb))

### 3. Получение AST

**Ключевые элементы вывода:**

- Узел `FunctionDecl` для square с параметром x.

- Узел `BinaryOperator` для операции x * x.

- Узел `CallExpr` для вызова square(a) в функции main.

Вывод:
AST точно отражает структуру программы, включая объявления функций и операций.
```bash
-Xclang -ast-dump -fsyntax-only main.c
```
![clang](![image](https://github.com/user-attachments/assets/3a056b14-b983-40ea-aa3e-e7fb45fe9234))
### 4. Генерация LLVM IR
Команда:
```bash
clang -S -emit-llvm main.c -o main.ll
```
![Файл](![image](https://github.com/user-attachments/assets/b9121a66-446b-4fb3-b588-8872506d2aec))

### 5. Оптимизация IR
**Шаг 1: Генерация неоптимизированного IR (O0):**
```bash
clang -O0 -S -emit-llvm main.c -o main_O0.ll
```
![image](https://github.com/user-attachments/assets/e0642165-c1b4-4c64-8c5f-1588747cfff9)


**Шаг 2: Генерация оптимизированного IR (O2):**
```bash
clang -O2 -S -emit-llvm main.c -o main_O2.ll
```
![image](https://github.com/user-attachments/assets/1673f3bd-125b-4c6d-8246-625f05c82903)

**Сравнение (diff):**
```bash
diff main_O0.ll main_O2.ll
```
![image](https://github.com/user-attachments/assets/7ccacbc1-8644-489a-af14-cebdb69fd69c)


**Изменения после оптимизации:**
- Функция `square` встроена в `main` (оптимизация -inline).

- Константа 25 подставлена напрямую (оптимизация -constprop).

- Удалены `alloca`, `load`, `store` (оптимизация -mem2reg).

**Вывод:**
Оптимизации значительно упростили код, устранив избыточные операции.

### 6. Граф потока управления программы
**Шаг 1: Генерация CFG:**

```bash
opt -passes=dot-cfg -disable-output main.ll
dot -Tpng .main.dot -o cfg_main.png
dot -Tpng .square.dot -o cfg_square.png
```
**Шаг 2: Визуализация:**
```bash
xdg-open cfg_main.png
xdg-open cfg_square.png
```

**Результат:**

- Граф для `main` содержит один блок (после оптимизации).

- Граф для `square` показывает блок с операцией `mul`.

**Вывод:**
CFG наглядно демонстрирует упрощение потока управления после оптимизаций.
![image](https://github.com/user-attachments/assets/ec9ac7a0-1c97-407d-86b2-b85858013647)
![image](https://github.com/user-attachments/assets/32215206-fc96-4e2b-816d-58426c37bb6e)

## Выводы по работе
- Clang предоставляет мощные инструменты для анализа кода через AST и IR.

- Оптимизации LLVM (-O2) радикально упрощают IR, удаляя избыточные операции.

- CFG помогает визуализировать логику программы, что полезно для отладки и оптимизации.

# Ответы на контрольные вопросы

## 1. Что такое Clang, и какова его роль в процессе компиляции программ?
**Clang** — это фронтенд-компилятор для языков C, C++ и Objective-C, разработанный как часть проекта LLVM. Его основные функции:
- Лексический, синтаксический и семантический анализ исходного кода
- Генерация абстрактного синтаксического дерева (AST)
- Преобразование AST в промежуточное представление LLVM IR
- Интеграция с инструментами статического анализа

Роль: Clang выступает "переводчиком" между исходным кодом и LLVM IR, подготавливая программу для дальнейших этапов компиляции.

---

## 2. Что представляет собой LLVM и как он используется в современных компиляторах?
**LLVM** (Low Level Virtual Machine) — это инфраструктура для создания компиляторов, включающая:
- Модульную систему оптимизаций
- Генератор машинного кода для различных архитектур
- Универсальное промежуточное представление (IR)

Использование:
1. В компиляторах (Rust, Swift используют LLVM как бекенд)
2. Для JIT-компиляции (например, в Julia)
3. В инструментах статического анализа (Clang Static Analyzer)

Пример: Apple использует LLVM в компиляторе Swift для кросс-платформенной поддержки.

---

## 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?

| Характеристика       | AST                          | LLVM IR                     |
|----------------------|------------------------------|-----------------------------|
| Уровень абстракции   | Высокоуровневое              | Низкоуровневое              |
| Зависимость от языка | Специфично для C/C++         | Языко-независимое           |
| Структура           | Дерево с узлами операторов   | Линейные инструкции в SSA   |
| Использование       | Для анализа кода             | Для оптимизаций и кодогенерации |

Пример: В AST оператор `a + b * c` сохраняет древовидную структуру, а в IR преобразуется в последовательность `%1 = mul, %2 = add`.

---

## 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?
Основные цели IR:
1. **Разделение фронтенда и бекенда**: Позволяет поддерживать новые языки без изменения оптимизатора
2. **Унификация оптимизаций**: Одни и те же оптимизации работают для разных языков
3. **Анализ кода**: Упрощает статический анализ и верификацию
4. **Поддержка различных целевых платформ**: Генерация машинного кода из одного IR для x86, ARM и др.

Пример: Clang преобразует C++ в IR, а затем LLVM генерирует код для ARM и x86 из одного IR.

---

## 5. Что делает инструкция `alloca` в LLVM IR, и зачем она используется в функциях?
Инструкция `alloca`:
- Выделяет память в стеке кадра функции
- Возвращает указатель на выделенную область
- Автоматически освобождается при выходе из функции

Использование:
```llvm
%x = alloca i32  ; Выделение 4 байт в стеке
store i32 5, i32* %x  ; Запись значения
%val = load i32, i32* %x  ; Чтение
```
Зачем нужно: Для работы с локальными переменными до применения оптимизации `mem2reg`.

---

## 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
Цели оптимизации:
1. Ускорение выполнения (пример: замена деления на степень двойки сдвигом).
2. Уменьшение размера кода (удаление мертвого кода)
3. Снижение энергопотребления (оптимизация циклов)
4. Улучшение предсказания ветвлений (разворот циклов)

Пример: Оптимизация -O2 в LLVM:

- Встраивание функций (inline)
- Распространение констант (constprop)
- Удаление общих подвыражений (gvn)

---

## 7. Что такое SSA-форма и почему она важна при оптимизации программ?

**SSA-форма** (Static Single Assignment) - это особый способ представления кода, при котором:
- Каждая переменная назначается **только один раз**
- Для слияния значений в точках ветвления используются φ-функции (phi-функции)

### Основные характеристики SSA:
1. **Уникальность определений**:
   ```llvm
   ; Не-SSA форма          ; SSA-форма
   %x = add i32 %a, 1      %x1 = add i32 %a, 1
   %x = mul i32 %x, 2      %x2 = mul i32 %x1, 2
   ```
2. Преимущества:
- Упрощает анализ зависимостей данных
- Позволяет применять оптимизации типа:
  1. Удаление мертвого кода (-dce)
  2. Распространение констант (-constprop)

---

## 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?

Граф потока управления (Control Flow Graph, CFG) — это ориентированный граф, в котором узлы представляют собой базовые блоки (последовательности инструкций без ветвлений), а рёбра указывают возможные переходы управления между ними. CFG помогает анализировать поведение программы, поскольку явно показывает, как управление передаётся между частями кода. Это важно для:
- Оптимизаций (например, удаление мёртвого кода),
- Анализа достижимости кода,
- Построения доминаторов и др.

---

## 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?

В LLVM IR арифметические операции выражаются как трёхадресные инструкции. Каждая операция имеет вид:  
`<результат> = <операция> <тип> <операнд1>, <операнд2>`  
Примеры:
- Сложение: `%sum = add i32 %a, %b`
- Умножение: `%product = mul i32 %x, %y`

Все операции строго типизированы, что делает IR пригодным для анализа и трансформаций.

---

## 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?

Функции в LLVM IR являются изолированными единицами с чётко определёнными входами и выходами. Это упрощает:
- Локальный анализ (например, обнаружение неиспользуемых переменных),
- Применение оптимизаций (например, инлайнинг, DCE),
- Повторное использование и компоновку,
- Возможность параллельного анализа и компиляции.

---

## 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?

LLVM применяет **инлайнинг**: короткая функция, вызываемая один раз, скорее всего будет встроена в место вызова. Это позволяет:
- Избежать накладных расходов на вызов,
- Раскрыть больше возможностей для последующих оптимизаций (например, константная свёртка).

---

## 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?

Использование промежуточного представления (IR) и CFG даёт несколько ключевых преимуществ:
- **Упрощённая структура**: IR лишён синтаксической сложности языков высокого уровня, как C.
- **Явная типизация и контроль потока**: облегчает анализ и трансформации.
- **Унификация**: единый формат позволяет применять одни и те же оптимизации ко всем языкам, транслируемым в LLVM IR.
- **Гибкость**: IR легко преобразуется и анализируется, что делает возможными агрессивные оптимизации, сложные на уровне исходного кода.
